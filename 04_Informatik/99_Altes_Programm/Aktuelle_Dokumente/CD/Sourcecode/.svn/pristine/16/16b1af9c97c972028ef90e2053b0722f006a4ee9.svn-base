package Robot;

import ch.ntb.inf.deep.runtime.ppc32.Task;
import definitions.RobotConstants;
import I_O_s.*;
import Communication.*;
import Sensors.*;
import motorController.*;

public class Robot extends Task {
	
	private static Communication communication;
	private static I_O_s ios;
	private static Sensors sensors;
	private static MotorController motors;
	boolean kom = true;
	boolean land = true;
	private static int platformPosition;
	private static int searchRound=0;
	private static int breakForSearching=RobotConstants.BREAK_TIME_FOR_SEARCHING;
	private States state = States.start;
	// acknowledge bit to check if it's the first message
	private int ack = 0;
	
	
	public Robot() throws Exception {
		communication = new Communication();
		ios = new I_O_s();
		//motors = new MotorController(parameters);
	}
	
	private static enum States {
		
		start,
		searchPosition,
		dockPosition,
		docking,
		tilting,
		landing,
		end
	}
	
	
	public void action(){
		
		switch(state){
			
		case start:
				ios.allLedOff();
				ios.allLedOn();				
				if(ios.getStartSwitch()){
					if(communication.getData() != RobotConstants.WIFI_CODE_ACK_START)
						communication.sendData(RobotConstants.WIFI_CODE_REQ_START);
					else if(communication.getData() == RobotConstants.WIFI_CODE_ACK_START){
						state = States.searchPosition;
						ios.allLedOff();
						// TODO go to search Position
					}
				}
				else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_START){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_START);
				}
				else if (communication.getData() != RobotConstants.WIFI_CODE_REQ_START && ack == 1){
					state = States.searchPosition;
					ios.allLedOff();
					// TODO go to searchposition
				}

			break;
		
		case searchPosition:
			if(true) {// TODO Method to know when reached searchposition
				ios.setLedSearch(!ios.getLedSearch());
				if(searchRound < RobotConstants.MAX_SEARCH_ROUND && breakForSearching >= RobotConstants.BREAK_TIME_FOR_SEARCHING){
					platformPosition=sensors.getPlatform();
					
					if(platformPosition != -1){
						communication.sendData(RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND);
						
						if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND);
							
							if(communication.getData() == RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND){
								state = States.dockPosition;
								ios.allLedOff();
								// TODO drive to dockPosition
							}
						}
						else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND);
							breakForSearching = 0;
							platformPosition = -1;
						}
					}
					else if(platformPosition == -1){
						communication.sendData(RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND);
						
						if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND);
							
							if(communication.getData() == RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND){
								state = States.dockPosition;
								ios.allLedOff();
								// TODO drive to dockPosition
							}
						}
						else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND);
							breakForSearching = 0;
							platformPosition = -1;
						}
					}
					searchRound ++;
				}
				breakForSearching++;
			}

			break;
			
		case dockPosition:

			if(true){// TODO Method to know when reached middleposition
				ios.setLedDock(true);
				boolean dockposition = true; // TODO Method to know when reached dock position
				if(dockposition && communication.getData() == RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION){
					state = States.docking;
					ios.allLedOff();
					// TODO Method do move to the other robot
				}
				else if(dockposition && communication.getData() == RobotConstants.WIFI_CODE_REQ_GOTO_DOCKPOSITION){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION);
				}
				else if(dockposition && communication.getData() != RobotConstants.WIFI_CODE_REQ_GOTO_DOCKPOSITION && ack == 1){
					ack = 0;
					state = States.docking;
					ios.allLedOff();
					// TODO Method do move to the other robot
				}
				else if(dockposition && communication.getData() != RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION){
					communication.sendData(RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION);
				}
			}
			
			break;
			
		case docking:
			if(true){// TODO Method to know when reached dockposition
				ios.setLedDock(!ios.getLedDock());
				
				if(sensors.getDock() && communication.getData() == RobotConstants.WIFI_CODE_ACK_START_DOCK){
					state = States.tilting;
					// TODO Method do move to the other robot
				}
				else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_START_DOCK){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_START_DOCK);
				}
				else if(sensors.getDock() && communication.getData() != RobotConstants.WIFI_CODE_REQ_START_DOCK && ack == 1){
					ack = 0;
					state = States.tilting;
					// TODO Method do move to the other robot
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_ACK_START_DOCK){
					communication.sendData(RobotConstants.WIFI_CODE_ACK_START_DOCK);
				}
			}
		
		break;
		
		case tilting:
			if(sensors.getDock()){
				ios.setLedTilt(!ios.getLedTilt());
				if(platformPosition != -1){
					// TODO Method to tilt the robot to our side
					// TODO Method to land on platform
					state = States.landing;
				}
				else if (platformPosition == -1){
					// TODO Method to tilt the robot to partner side
					state = States.landing;	
				}
			}
			else{
				communication.sendData(RobotConstants.WIFI_CODE_REQ_ERROR_DOCK);
				// TODO Method to stop program
			}
			
			break;

		case landing:
			if(true){// TODO Method to know when tilted
				ios.setLedLand(!ios.getLedLand());
				if (communication.getData() == RobotConstants.WIFI_CODE_ACK_GOTO_PLATFORM){
					ios.allLedOff();
					state = States.end;
				}
				else if (communication.getData() == RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_GOTO_PLATFORM);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM && ack == 1){
					ack = 0;
					ios.allLedOff();
					state = States.end;
				}
				else if (communication.getData() != RobotConstants.WIFI_CODE_ACK_GOTO_PLATFORM){
					communication.sendData(RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM);
				}
			}
			
			break;
		
		case end:	
			if(true){// TODO Method to know when landed
				ios.setLedLand(true);
				if (communication.getData() == RobotConstants.WIFI_CODE_ACK_END){
					ios.allLedOff();
				}
				else if (communication.getData() == RobotConstants.WIFI_CODE_REQ_END){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_END);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_REQ_END && ack == 1){
					ack = 0;
					ios.allLedOff();
				}
				else if (communication.getData() != RobotConstants.WIFI_CODE_ACK_END){
					communication.sendData(RobotConstants.WIFI_CODE_REQ_END);
				}
			}
			
			break;
		
		default:
			
			break;
		}
	}
	
	static {		
		
		// Initialize task

		try {
			Robot task = new Robot();
			task.period = RobotConstants.STATE_MACHINE_TASK_PERIOD;
			Task.install(task);
			
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

}