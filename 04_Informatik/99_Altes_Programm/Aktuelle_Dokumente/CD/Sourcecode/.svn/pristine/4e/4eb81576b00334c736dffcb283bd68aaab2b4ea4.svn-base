package Robot;

import ch.ntb.inf.deep.runtime.mpc555.driver.SCI;
import ch.ntb.inf.deep.runtime.ppc32.Task;
import definitions.PinMap;
import definitions.RobotConstants;
import I_O_s.*;

import java.io.PrintStream;

import Communication.*;
import Sensors.*;
import motorController.*;

public class Robot extends Task {
	
	private static Communication communication;
	private static I_O_s ios;
	private static Sensors sensors;
	private static MotorController motorLeft;
	private static MotorController motorRight;
	private static MotorController motorFront;
	private static int platformPosition=0;
	private static int searchRound=0;
	private static int breakForSearching=RobotConstants.BREAK_TIME_FOR_SEARCHING;
	private States state = States.start;
	// acknowledge bit to check if it's the first message
	private int ack = 0;
	
	
	public Robot() throws Exception {
		communication = new Communication();
		ios = new I_O_s();
		sensors = new Sensors();
		motorLeft = new MotorController(RobotConstants.USE_TPUA, PinMap.ROPE_LEFT_PWM_PLUS_TPU_PIN, PinMap.ROPE_LEFT_PWM_MINUS_TPU_PIN, PinMap.ROPE_LEFT_ENC_A_TPU_PIN);
		motorRight = new MotorController(RobotConstants.USE_TPUA, PinMap.ROPE_RIGHT_PWM_PLUS_TPU_PIN, PinMap.ROPE_RIGHT_PWM_MINUS_TPU_PIN, PinMap.ROPE_FRONT_ENC_A_TPU_PIN);
//		motorFront = new MotorController(RobotConstants.USE_TPUA, PinMap.ROPE_FRONT_PWM_PLUS_TPU_PIN, PinMap.ROPE_FRONT_PWM_MINUS_TPU_PIN, PinMap.ROPE_FRONT_ENC_A_TPU_PIN);
		period = RobotConstants.STATE_MACHINE_TASK_PERIOD;
		Task.install(this);
		ios.setLRDisableSleep(true);
		ios.setFDisableSleep(false);
		ios.allLedOff();
		ios.setMagnet(false);
	}
	
	private static enum States {
		
		start,
		searchPosition,
		dockPosition,
		docking,
		tilting,
		landing,
		end
	}
	
	
	public void action(){
		
		switch(state){
			
		case start:
//				ios.allLedOff();
//				ios.allLedOn();				
				if(!ios.getStartSwitch()){
					if(communication.getData() != RobotConstants.WIFI_CODE_ACK_START){
						communication.sendData(RobotConstants.WIFI_CODE_REQ_START);
					}
					else if(communication.getData() == RobotConstants.WIFI_CODE_ACK_START){
						// TODO go to search Position
						nextState(States.searchPosition, 200, 200, 150);
					}
				}
				else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_START){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_START);
				}
				else if (communication.getData() != RobotConstants.WIFI_CODE_REQ_START && ack == 1){
					// TODO go to searchposition
					nextState(States.searchPosition, 200, 200, 150);
				}

			break;
		
		case searchPosition:
			if(motorLeft.reachedDesiredPosition() && motorRight.reachedDesiredPosition()) {// TODO Method to know when reached searchposition
				ios.setLedSearch(!ios.getLedSearch());
				if(/**searchRound < RobotConstants.MAX_SEARCH_ROUND && breakForSearching >= RobotConstants.BREAK_TIME_FOR_SEARCHING**/true){
					platformPosition=sensors.getPlatform();
					
					if(platformPosition != -1){
						communication.sendData(RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND);
						
						if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND);
							
//							if(communication.getData() == RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND){
								// TODO drive to dockPosition
								nextState(States.dockPosition, 500, 500, 450);
//							}
						}
						else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND);
							breakForSearching = 0;
							platformPosition = -1;
						}
					}
					else if(platformPosition == -1){
						communication.sendData(RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND);
						
						if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND);
							
//							if(communication.getData() == RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND){
								// TODO drive to dockPosition
								nextState(States.dockPosition, 500, 500, 450);
//							}
						}
						else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND){
							communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND);
							breakForSearching = 0;
							platformPosition = -1;
						}
					}
					searchRound ++;
				}
				breakForSearching++;
			}

			break;
			
		case dockPosition:

			if(motorLeft.reachedDesiredPosition() && motorRight.reachedDesiredPosition()){// TODO Method to know when reached middleposition
				ios.setLedDock(true);
				
				if(communication.getData() == RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION){
					// TODO Method do move to the other robot
					ios.setMagnet(true);
					nextState(States.docking, 600);
				}
				else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_GOTO_DOCKPOSITION){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_REQ_GOTO_DOCKPOSITION && ack == 1){
					// TODO Method do move to the other robot
					ios.setMagnet(true);
					nextState(States.docking, 600);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION){
					communication.sendData(RobotConstants.WIFI_CODE_ACK_GOTO_DOCKPOSITION);
				}
			}
			
			break;
			
		case docking:
			if(true){// TODO Method to know when reached dockposition (motorFront.reachedDesiredPosition())
				ios.setLedDock(!ios.getLedDock());
				
				if(sensors.getDock() && communication.getData() == RobotConstants.WIFI_CODE_ACK_START_DOCK){
					// TODO Method do move to the other robot
					nextState(States.tilting);
				}
				else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_START_DOCK){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_START_DOCK);
				}
				else if(sensors.getDock() && communication.getData() != RobotConstants.WIFI_CODE_REQ_START_DOCK && ack == 1){
					// TODO Method do move to the other robot
					nextState(States.tilting);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_ACK_START_DOCK){
					communication.sendData(RobotConstants.WIFI_CODE_REQ_START_DOCK);
				}
			}
		
		break;
		
		case tilting:
			if(sensors.getDock()){
				ios.setLedTilt(!ios.getLedTilt());
				if(platformPosition != -1){
					// TODO Method to tilt the robot to our side
					nextState(States.landing, 0);
				}
				else if (platformPosition == -1){
					communication.sendData(RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM);
					nextState(States.end, 0, 0, 0);
				}
			}
			else{
				communication.sendData(RobotConstants.WIFI_CODE_REQ_ERROR_DOCK);
				// TODO Method to stop program
			}
			
			break;

		case landing:
			if(true){// TODO Method to know when tilted (motorFront.reachedDesiredPosition())
				ios.setLedLand(!ios.getLedLand());
//				if (communication.getData() == RobotConstants.WIFI_CODE_ACK_GOTO_PLATFORM){
//					ios.allLedOff();
//					state = States.end;
//
//				}
				if (communication.getData() == RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_GOTO_PLATFORM);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM && ack == 1){
					if(platformPosition == 1)
					{
						// TODO wait for PID
						nextState(States.end, 0, 0);
					}
					else if(platformPosition == 2)
					{
						nextState(States.end, 0, 0);
					}
					else if(platformPosition == 3)
					{
						// TODO wait for PID
						nextState(States.end, 0, 0);
					}
				}
//				else if (communication.getData() != RobotConstants.WIFI_CODE_ACK_GOTO_PLATFORM){
//					communication.sendData(RobotConstants.WIFI_CODE_REQ_GOTO_PLATFORM);
//				}
			}
			
			break;
		
		case end:	
			if(motorLeft.reachedDesiredPosition() && motorRight.reachedDesiredPosition()){
				ios.setLedLand(true);
				if (communication.getData() == RobotConstants.WIFI_CODE_ACK_END){
					ios.allLedOff();
				}
				else if (communication.getData() == RobotConstants.WIFI_CODE_REQ_END){
					ack = 1;
					communication.sendData(RobotConstants.WIFI_CODE_ACK_END);
				}
				else if(communication.getData() != RobotConstants.WIFI_CODE_REQ_END && ack == 1){
					ios.allLedOff();
				}
				else if (communication.getData() != RobotConstants.WIFI_CODE_ACK_END){
					communication.sendData(RobotConstants.WIFI_CODE_REQ_END);
				}
			}
			
			break;
		
		default:
			
			break;
		}
	}
	
	private void nextState(States State){
		ack = 0;
		ios.allLedOff();
		state = State;
	}
	
	private void nextState(States State, double motorFrontPosition){
		motorLeft.setDesiredPosition(motorFrontPosition);
		nextState(State);
	}
	
	private void nextState(States State, double motorLeftPosition, double motorRightPosition){
		motorLeft.setDesiredPosition(motorLeftPosition);
		motorRight.setDesiredPosition(motorRightPosition);	
		nextState(State);
	}
	
	private void nextState(States State, double motorLeftPosition, double motorRightPosition, double motorFrontPosition){
		motorLeft.setDesiredPosition(motorLeftPosition);
		motorRight.setDesiredPosition(motorRightPosition);
		motorFront.setDesiredPosition(motorFrontPosition);
		nextState(State);
	}
	
	static {		
		
		// Initialize task

		try {
			new Robot();
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		SCI sci1 = SCI.getInstance(SCI.pSCI1);
		sci1.start(19200, SCI.NO_PARITY, (short)8);
		System.out = new PrintStream(sci1.out);
		System.out.print("Roboter");
	}

}