package Robot;

import ch.ntb.inf.deep.runtime.ppc32.Task;
import definitions.RobotConstants;
import I_O_s.*;
import Communication.*;
import Sensors.*;

public class Robot extends Task {
	
	private static Communication communication;
	private static I_O_s ios;
	private static Sensors sensors;
	boolean kom = true;
	boolean land = true;
	int i =0;
	private static int platformPosition;
	private static int searchRound=0;
	private static int breakForSearching=RobotConstants.BREAK_TIME_FOR_SEARCHING;
	private static final boolean setLED =true;
	
	public Robot() throws Exception {
		communication = new Communication();
		ios = new I_O_s();
	}
	
	private static enum States
	{
		booting,
		start,
		searchPosition,
		dockPosition,
		tilting,
		end,
		communicationFailure
	}
	
	private States state = States.booting;
	public void action(){
		
		switch(state){
		
		case booting:
			ios.setLedSearch(setLED);
			ios.setLedDock(setLED);
			ios.setLedLand(setLED);
			ios.setLedCommunication(setLED);
			ios.setLedReserve(setLED);
			
			if(ios.getStartSwitch()){
				Communication.sendData(RobotConstants.WIFI_CODE_REQ_START);
				state = States.start;
			}
			else if(communication.getData()==RobotConstants.WIFI_CODE_REQ_START){
				Communication.sendData(RobotConstants.WIFI_CODE_ACK_START);
				state =States.start;
			}
			
			break;
			
		case start:
			ios.allLedOff();
			// TODO go to search Position
			ios.setLedSearch(!ios.getLedSearch());
			if(true) {// TODO Method to know when reached searchposition
				state = States.searchPosition;	
			} 
			break;
			
		case searchPosition:
			ios.setLedSearch(setLED);
			if(searchRound<RobotConstants.MAX_SEARCH_ROUND && breakForSearching >= RobotConstants.BREAK_TIME_FOR_SEARCHING){
				platformPosition=sensors.getPlatform();
				
				if(platformPosition != -1){
					Communication.sendData(RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND);
					
					if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND){
						Communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND);
						
						if(communication.getData() == RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND){
							state = States.dockPosition;
							// TODO drive to dockPosition
						}
					}
					else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND){
						Communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND);
						breakForSearching = 0;
						platformPosition = -1;
						
					}
				}
				else if(platformPosition == -1){
					Communication.sendData(RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND);
					
					if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_FOUND){
						Communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_FOUND);
						
						if(communication.getData() == RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND){
							state = States.dockPosition;
							// TODO drive to dockPosition
						}
					}
					else if(communication.getData() == RobotConstants.WIFI_CODE_REQ_PLATFORM_NOT_FOUND){
						Communication.sendData(RobotConstants.WIFI_CODE_ACK_PLATFORM_NOT_FOUND);
						breakForSearching = 0;
						platformPosition = -1;
					}
				}
			}
			breakForSearching++;
		
			break;
			
		case dockPosition:
			ios.allLedOff();
			ios.setLedDock(!ios.getLedDock());
			boolean dockposition = true; // TODO Method to know when reached dock position
			if(dockposition && communication.getData() == RobotConstants.WIFI_CODE_REQ_START_DOCK){
				Communication.sendData(RobotConstants.WIFI_CODE_ACK_START_DOCK);
				// TODO Method do move to the other robot
				state = States.tilting;
			}
			else if(dockposition && communication.getData() == RobotConstants.WIFI_CODE_ACK_START_DOCK){
				// TODO Method do move to the other robot
				state = States.tilting;
			}
			else if(dockposition){
				Communication.sendData(RobotConstants.WIFI_CODE_REQ_START_DOCK);
			}
			
			break;
		
		case tilting:
			ios.setLedDock(setLED);
			if(sensors.getDock() && platformPosition != -1){
				// TODO Method to tilt the robot to our side
				// TODO Method to land on platform
				state = States.end;
			
			}
			else if (sensors.getDock() && platformPosition == -1){
				// TODO Method to tilt the robot to partner side
				state = States.end;
				
			}
			else{
				Communication.sendData(RobotConstants.WIFI_CODE_ERROR_DOCK);
				// TODO Method to stop the motors
				// TODO drive to dockPosition
				state = States.dockPosition;
			}
			
			break;
			
		case end:
			boolean landed = true; // TODO Method to know when landed on platform
			if (communication.getData() == RobotConstants.WIFI_CODE_REQ_END){
				Communication.sendData(RobotConstants.WIFI_CODE_ACK_END);
			}
			else if (landed && communication.getData() == RobotConstants.WIFI_CODE_ACK_END){
				
			}
			else if(landed){
				Communication.sendData(RobotConstants.WIFI_CODE_REQ_END);
			}
			
			break;
			
		case communicationFailure:
			
			break;
			
		default:
			
			break;
		}
	}
	

	static {		
		
		// Initialize task

		try {
			Robot task = new Robot();
			task.period = RobotConstants.STATE_MACHINE_TASK_PERIOD;
			Task.install(task);
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}